use std::{collections::HashMap, marker::PhantomData};

use error::Error;

use crate::{Lexer, Token};

pub(crate) mod error;
mod macros;

/// Result type used by [Table::parse] [Table::parse_at] and parser functions
pub type Result<T, Ast> = std::result::Result<Ast, Error<T>>;

/// Generated by the assoc macro on behalf of the pratt macro
#[doc(hidden)]
#[repr(u8)]
#[derive(Debug, Copy, Clone)]
pub enum Assoc {
    R = 0,
    L = 1,
}

type PrefixParser<Token, Context, Ast> = fn(
    &Table<Token, Context, Ast>,
    &mut dyn Lexer<Token = Token, Context = Context>,
    Context,
) -> Result<Token, Ast>;
type InfixParser<Token, Context, Ast> = fn(
    &Table<Token, Context, Ast>,
    &mut dyn Lexer<Token = Token, Context = Context>,
    Context,
    Ast,
) -> Result<Token, Ast>;

struct Row<T: Token, Context: Copy, Ast> {
    prefix: Option<PrefixParser<T, Context, Ast>>,
    infix: Option<InfixParser<T, Context, Ast>>,
    bind: u8,
    assoc: Assoc,
}

impl<T: Token, Context: Copy, Ast> Row<T, Context, Ast> {
    const EMPTY: Self = Row {
        prefix: None,
        infix: None,
        bind: 0,
        assoc: Assoc::R,
    };
}

/// Pratt table
///
/// # Example
#[doc = include_str!("table/example.rs")]
#[allow(missing_debug_implementations)]
pub struct Table<T: Token, Context: Copy, Ast> {
    _context: PhantomData<fn(Context)>,
    table: HashMap<T::Type, Row<T, Context, Ast>>,
    binders: HashMap<&'static str, u8>,
}

impl<T: Token + std::fmt::Debug, Context: Copy, Ast> Table<T, Context, Ast> {
    const MIN_BIND: u8 = 1;

    /// Implementation detail of the pratt macro
    ///
    /// Create a new empty table
    #[doc(hidden)]
    #[must_use]
    pub fn new() -> Self {
        Table {
            _context: PhantomData,
            table: HashMap::new(),
            binders: HashMap::new(),
        }
    }

    /// Parse a sequence of tokens regardless of binding power
    pub fn parse(
        &self,
        lexer: &mut dyn Lexer<Token = T, Context = Context>,
        context: Context,
    ) -> Result<T, Ast> {
        self.parse_at_raw(lexer, context, Self::MIN_BIND)
    }

    /// Parse a sequence of tokens with respect to a specific binding power
    ///
    /// The parser will stop consuming tokens when it encounters an infix token
    /// who's binding power is lower than the chosen binding power (e.g the
    /// token binds less strongly than the currently selected binding power and
    /// should occur closer to the root of the resulting parse tree)
    pub fn parse_at(
        &self,
        lexer: &mut dyn Lexer<Token = T, Context = Context>,
        context: Context,
        token: T::Type,
    ) -> Result<T, Ast> {
        self.parse_at_raw(lexer, context, self.bind_of(token))
    }

    fn parse_at_raw(
        &self,
        lexer: &mut dyn Lexer<Token = T, Context = Context>,
        context: Context,
        bind: u8,
    ) -> Result<T, Ast> {
        let prefix = self
            .row(lexer.peek(context).map(Token::typ).as_ref())
            .prefix
            .ok_or_else(|| {
                if let Some(token) = lexer.token(context) {
                    Error::UnexpectedToken(token, None)
                } else {
                    Error::UnexpectedEOF(None)
                }
            })?;
        let mut lhs = prefix(self, lexer, context)?;

        while let Some(token) = lexer.peek(context) {
            let row = self.row(Some(&token.typ()));
            if bind > row.bind {
                break;
            }
            let Some(infix) = row.infix else {
                break;
            };
            lhs = infix(self, lexer, context, lhs)?;
        }

        Ok(lhs)
    }

    /// Implementation detail of the bind macro
    ///
    /// Look up a previously saved raw binding power by name, see
    /// [Table::save_bind]
    #[doc(hidden)]
    #[must_use]
    pub fn bind(&self, level: &'static str) -> u8 {
        self.binders[level]
    }

    /// Look up the binding power of a token, usable with [Table::parse_at] to
    /// control precedence levels for infix parsing. Binding power is adjusted
    /// to account for the token's declared associativity
    ///
    /// This method is only relevant for token types with defined infix parsers
    #[must_use]
    pub fn bind_of(&self, token: T::Type) -> u8 {
        let row = self.row(Some(&token));

        debug_assert!(
            row.infix.is_some(),
            "Binding power is only relevant for infix tokens"
        );

        row.bind + (row.assoc as u8)
    }

    /// Implementation detail of the save_bind macro
    ///
    /// Store the raw binding power (not offset to account for associativity) of
    /// a specific token that already exists in the table under a given name
    #[doc(hidden)]
    pub fn name_bind(&mut self, token: &T::Type, name: &'static str) {
        let _ = self.binders.insert(name, self.table[token].bind);
    }

    /// Implementation detail of the pratt macro
    ///
    /// Add a new row to the table
    #[doc(hidden)]
    pub fn add_row(
        &mut self,
        token: T::Type,
        prefix: Option<PrefixParser<T, Context, Ast>>,
        infix: Option<InfixParser<T, Context, Ast>>,
        bind: u8,
        assoc: Assoc,
    ) {
        let _ = self.table.insert(
            token,
            Row {
                prefix,
                infix,
                bind,
                assoc,
            },
        );
    }

    fn row(&self, token: Option<&T::Type>) -> &Row<T, Context, Ast> {
        let Some(token) = token else {
            return &Row::EMPTY;
        };
        if let Some(row) = self.table.get(token) {
            row
        } else {
            &Row::EMPTY
        }
    }
}

#[cfg(test)]
mod tests {
    use std::sync::LazyLock;

    use super::*;
    use crate::Token as _;

    #[derive(Debug, Copy, Clone, PartialEq, pratt_derive::Token)]
    enum Token {
        #[pratt(payload = *it)]
        Atom(char),
        #[pratt(payload = '+')]
        Add,
        #[pratt(payload = '-')]
        Sub,
        #[pratt(payload = '*')]
        Mul,
        #[pratt(payload = '/')]
        Div,
        #[pratt(payload = '=')]
        Assig,
        #[pratt(payload = "Custom")]
        Custom,
    }

    #[derive(Debug, PartialEq)]
    enum Ast {
        Assig(Box<Ast>, Box<Ast>),
        BinOp(char, Box<Ast>, Box<Ast>),
        Atom(char),
    }

    type Table = super::Table<Token, (), Ast>;
    type Lexer<'a> = crate::LexerHandle<'a, Token, ()>;

    #[allow(clippy::unnecessary_wraps)]
    #[pratt_derive::prefix]
    fn atom(_: &Table, tokens: &mut Lexer<'_>, (): ()) -> Result<Token, Ast> {
        let c = demand!(Token::Atom(c) => *c);
        Ok(Ast::Atom(c))
    }

    #[pratt_derive::infix]
    fn assig(
        table: &Table,
        lexer: &mut Lexer<'_>,
        (): (),
        lhs: Ast,
    ) -> Result<Token, Ast> {
        demand!(Token::Assig);
        let rhs = table.parse_at(lexer, (), Token::Assig.typ())?;
        Ok(Ast::Assig(Box::new(lhs), Box::new(rhs)))
    }

    #[pratt_derive::infix]
    fn op(
        table: &Table,
        lexer: &mut Lexer<'_>,
        (): (),
        lhs: Ast,
    ) -> Result<Token, Ast> {
        let tok =
            demand!(tok@(Token::Add|Token::Sub|Token::Div|Token::Mul) => *tok);
        let op = tok.payload().chars().next().unwrap();
        let rhs = table.parse_at(lexer, (), tok.typ())?;
        Ok(Ast::BinOp(op, Box::new(lhs), Box::new(rhs)))
    }

    fn always_fails(
        _: &Table,
        _: &mut Lexer<'_>,
        (): (),
    ) -> Result<Token, Ast> {
        Err(Error::Custom("Custom Error".into()))
    }

    static TABLE: LazyLock<Table> = LazyLock::new(|| {
        crate::pratt! {
            Assig =>  [     , assig, R,     _ ];
            Add   =>  [     ,    op, L,  PLUS ];
            Sub   =>  [     ,    op, L, =PLUS ];
            Mul   =>  [     ,    op, L,   MUL ];
            Div   =>  [     ,    op, L,  =MUL ];
            Atom  =>  [ atom,      , _,     _ ];
            Custom => [ always_fails, ,_,_];
        }
    });

    #[test]
    fn parse_success() -> Result<Token, ()> {
        let mut tokens = {
            use self::Token::*;
            // a  + b - c * d  / e
            vec![
                Atom('a'),
                Add,
                Atom('b'),
                Sub,
                Atom('c'),
                Mul,
                Atom('d'),
                Div,
                Atom('e'),
            ]
            .into_iter()
            .peekable()
        };

        let result = TABLE.parse(&mut tokens, ())?;

        let expected = Ast::BinOp(
            '-',
            Box::new(Ast::BinOp(
                '+',
                Box::new(Ast::Atom('a')),
                Box::new(Ast::Atom('b')),
            )),
            Box::new(Ast::BinOp(
                '/',
                Box::new(Ast::BinOp(
                    '*',
                    Box::new(Ast::Atom('c')),
                    Box::new(Ast::Atom('d')),
                )),
                Box::new(Ast::Atom('e')),
            )),
        );

        assert_eq!(expected, result);
        assert!(tokens.collect::<Vec<_>>().is_empty());

        Ok(())
    }

    #[test]
    fn precedence() -> Result<Token, ()> {
        let mut tokens = {
            use self::Token::*;
            //         a     *         b     -         c
            vec![Atom('a'), Mul, Atom('b'), Sub, Atom('c')]
                .into_iter()
                .peekable()
        };

        let result = TABLE.parse(&mut tokens, ())?;

        let expected = Ast::BinOp(
            '-',
            Box::new(Ast::BinOp(
                '*',
                Box::new(Ast::Atom('a')),
                Box::new(Ast::Atom('b')),
            )),
            Box::new(Ast::Atom('c')),
        );

        assert_eq!(expected, result);
        assert!(tokens.collect::<Vec<_>>().is_empty());

        Ok(())
    }

    #[test]
    fn left_associativity() -> Result<Token, ()> {
        let mut tokens = {
            use self::Token::*;
            //         a     +         b     +         c
            vec![Atom('a'), Add, Atom('b'), Add, Atom('c')]
                .into_iter()
                .peekable()
        };

        let result = TABLE.parse(&mut tokens, ())?;

        let expected = Ast::BinOp(
            '+',
            Box::new(Ast::BinOp(
                '+',
                Box::new(Ast::Atom('a')),
                Box::new(Ast::Atom('b')),
            )),
            Box::new(Ast::Atom('c')),
        );

        assert_eq!(expected, result);
        assert!(tokens.collect::<Vec<_>>().is_empty());

        Ok(())
    }

    #[test]
    fn right_associativity() -> Result<Token, ()> {
        let mut tokens = {
            use self::Token::*;
            //         a      =          b      =          c
            vec![Atom('a'), Assig, Atom('b'), Assig, Atom('c')]
                .into_iter()
                .peekable()
        };

        let result = TABLE.parse(&mut tokens, ())?;

        let expected = Ast::Assig(
            Box::new(Ast::Atom('a')),
            Box::new(Ast::Assig(
                Box::new(Ast::Atom('b')),
                Box::new(Ast::Atom('c')),
            )),
        );

        assert_eq!(expected, result);
        assert!(tokens.collect::<Vec<_>>().is_empty());

        Ok(())
    }

    #[test]
    fn parser_has_no_semantic_awareness() -> Result<Token, ()> {
        let mut tokens = {
            use self::Token::*;
            //         a     +         b      =          c
            vec![Atom('a'), Add, Atom('b'), Assig, Atom('c')]
                .into_iter()
                .peekable()
        };

        let result = TABLE.parse(&mut tokens, ())?;

        let expected = Ast::Assig(
            Box::new(Ast::BinOp(
                '+',
                Box::new(Ast::Atom('a')),
                Box::new(Ast::Atom('b')),
            )),
            Box::new(Ast::Atom('c')),
        );

        assert_eq!(expected, result);
        assert!(tokens.collect::<Vec<_>>().is_empty());

        Ok(())
    }

    #[test]
    fn parse_at() -> Result<Token, ()> {
        let tokens = {
            use self::Token::*;
            //         a     *         b     +         c      =          d
            vec![Atom('a'), Mul, Atom('b'), Add, Atom('c'), Assig, Atom('d')]
        };

        {
            // Passing Token::Mul to parse_at tells the parser we're in the middle
            // of parsing a multiplication (or division since they have the same
            // binding power). Since multiplication is left associative it shouldn't
            // parse a second multiplication for the rhs
            let mut tokens = tokens.clone().into_iter().peekable();

            let result = TABLE.parse_at(&mut tokens, (), Token::Mul.typ())?;

            let expected = Ast::Atom('a');
            let remainder = {
                use self::Token::*;
                vec![Mul, Atom('b'), Add, Atom('c'), Assig, Atom('d')]
            };

            assert_eq!(expected, result);
            assert_eq!(remainder, tokens.collect::<Vec<_>>());
        }

        {
            // If we use Token::Add instead it should consume the whole
            // multiplication expression since that is a valid child node for an
            // addition. As + is also left associative the + and the last atom
            // shouldn't be consumed
            let mut tokens = tokens.clone().into_iter().peekable();

            let result = TABLE.parse_at(&mut tokens, (), Token::Add.typ())?;

            let expected = Ast::BinOp(
                '*',
                Box::new(Ast::Atom('a')),
                Box::new(Ast::Atom('b')),
            );
            let remainder = {
                use self::Token::*;
                vec![Add, Atom('c'), Assig, Atom('d')]
            };

            assert_eq!(expected, result);
            assert_eq!(remainder, tokens.collect::<Vec<_>>());
        }

        {
            // If we use Token::Assig instead it should consume the entire
            // expression should be consumed as it is a valid rhs for = in it's
            // entirety (including the second = since it's right associative &
            // ignoring semantic sensibility)
            let mut tokens = tokens.clone().into_iter().peekable();

            let result = TABLE.parse_at(&mut tokens, (), Token::Assig.typ())?;

            let expected = Ast::Assig(
                Box::new(Ast::BinOp(
                    '+',
                    Box::new(Ast::BinOp(
                        '*',
                        Box::new(Ast::Atom('a')),
                        Box::new(Ast::Atom('b')),
                    )),
                    Box::new(Ast::Atom('c')),
                )),
                Box::new(Ast::Atom('d')),
            );

            assert_eq!(expected, result);
            assert!(tokens.collect::<Vec<_>>().is_empty());
        }

        Ok(())
    }

    #[test]
    fn eof_error() {
        let result = TABLE.parse(
            &mut {
                use self::Token::*;
                vec![Atom('a'), Add].into_iter().peekable()
            },
            (),
        );
        assert!(matches!(result, Err(Error::UnexpectedEOF(None))));
    }

    #[test]
    fn unexpected_token_error() {
        let result = TABLE.parse(
            &mut {
                use self::Token::*;
                vec![Add].into_iter().peekable()
            },
            (),
        );
        assert!(matches!(
            result,
            Err(Error::UnexpectedToken(Token::Add, None))
        ));
    }

    #[test]
    fn custom_error() {
        let result =
            TABLE.parse(&mut vec![Token::Custom].into_iter().peekable(), ());
        assert!(matches!(result, Err(Error::Custom(_))));
    }
}
